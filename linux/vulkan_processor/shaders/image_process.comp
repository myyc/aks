#version 450

// Workgroup size
layout (local_size_x = 16, local_size_y = 16) in;

// Input/output buffers (using uints for byte data)
layout (std430, binding = 0) readonly buffer InputBuffer {
    uint data[];
} inputBuffer;

layout (std430, binding = 1) writeonly buffer OutputBuffer {
    uint data[];
} outputBuffer;

// Adjustment parameters (uniform buffer)
layout (binding = 2) uniform AdjustmentParams {
    // White balance
    float temperature;
    float tint;
    
    // Exposure and contrast
    float exposure;
    float contrast;
    
    // Highlights and shadows
    float highlights;
    float shadows;
    
    // Blacks and whites
    float blacks;
    float whites;
    
    // Saturation and vibrance
    float saturation;
    float vibrance;
    
    // Tone curve enable flag and image dimensions
    float toneCurveEnabled;
    float imageWidth;
    float imageHeight;
    float padding;
    
    // Crop parameters (normalized 0-1)
    float cropLeft;
    float cropTop;
    float cropRight;
    float cropBottom;
} params;

// Tone curve lookup tables (256 bytes each, packed as 64 uints)
layout (std430, binding = 3) readonly buffer RgbLut {
    uint data[64];  // 256 bytes
} rgbLut;

layout (std430, binding = 4) readonly buffer RedLut {
    uint data[64];  // 256 bytes
} redLut;

layout (std430, binding = 5) readonly buffer GreenLut {
    uint data[64];  // 256 bytes
} greenLut;

layout (std430, binding = 6) readonly buffer BlueLut {
    uint data[64];  // 256 bytes
} blueLut;

// Helper functions

// Get value from LUT buffer (packed as bytes in uints)
uint getLutValue(uint lutData[64], uint index) {
    uint wordIndex = index / 4;  // Which uint contains this byte
    uint byteIndex = index % 4;  // Which byte within the uint
    uint word = lutData[wordIndex];
    
    // Extract the byte (little-endian)
    return (word >> (byteIndex * 8)) & 0xFF;
}

// Apply tone curves using lookup tables
vec3 applyToneCurves(vec3 color) {
    if (params.toneCurveEnabled == 0.0) {
        return color;
    }
    
    // Convert to 0-255 range
    ivec3 indices = ivec3(clamp(color * 255.0, 0.0, 255.0));
    
    // Apply RGB master curve first
    indices.r = int(getLutValue(rgbLut.data, uint(indices.r)));
    indices.g = int(getLutValue(rgbLut.data, uint(indices.g)));
    indices.b = int(getLutValue(rgbLut.data, uint(indices.b)));
    
    // Then apply individual channel curves
    indices.r = int(getLutValue(redLut.data, uint(indices.r)));
    indices.g = int(getLutValue(greenLut.data, uint(indices.g)));
    indices.b = int(getLutValue(blueLut.data, uint(indices.b)));
    
    // Convert back to 0-1 range
    return vec3(indices) / 255.0;
}

vec3 applyWhiteBalance(vec3 color, float temperature, float tint) {
    // Temperature adjustment (blue-yellow axis)
    float tempScale = (temperature - 5500.0) / 5500.0;
    color.r *= 1.0 + tempScale * 0.5;
    color.b *= 1.0 - tempScale * 0.5;
    
    // Tint adjustment (green-magenta axis)
    float tintScale = tint / 150.0;
    color.g *= 1.0 - abs(tintScale) * 0.3;
    if (tintScale > 0) {
        color.r *= 1.0 + tintScale * 0.2;
        color.b *= 1.0 + tintScale * 0.2;
    }
    
    return color;
}

vec3 applyExposure(vec3 color, float exposure) {
    return color * pow(2.0, exposure);
}

vec3 applyContrast(vec3 color, float contrast) {
    float factor = (100.0 + contrast) / 100.0;
    return (color - 0.5) * factor + 0.5;
}

vec3 applyHighlightsShadows(vec3 color, float highlights, float shadows) {
    float luminance = dot(color, vec3(0.299, 0.587, 0.114));
    
    // Use mix to avoid branching - smoother performance
    // Shadows: affect darker areas (luminance < 0.5)
    float shadowWeight = smoothstep(0.5, 0.0, luminance);
    float shadowFactor = mix(1.0, 1.0 + (shadows / 100.0) * (1.0 - luminance * 2.0), shadowWeight * step(0.001, abs(shadows)));
    
    // Highlights: affect brighter areas (luminance > 0.5)
    float highlightWeight = smoothstep(0.5, 1.0, luminance);
    float highlightFactor = mix(1.0, 1.0 + (highlights / 100.0) * ((luminance - 0.5) * 2.0), highlightWeight * step(0.001, abs(highlights)));
    
    // Apply both factors (they affect different ranges)
    color *= shadowFactor * highlightFactor;
    
    return color;
}

vec3 applyBlacksWhites(vec3 color, float blacks, float whites) {
    float blackPoint = blacks > 0 ? blacks * 0.005 : blacks * 0.003;
    float whitePoint = 1.0 + (whites > 0 ? whites * 0.005 : whites * 0.003);
    
    return (color - blackPoint) / (whitePoint - blackPoint);
}

vec3 applySaturationVibrance(vec3 color, float saturation, float vibrance) {
    float gray = dot(color, vec3(0.299, 0.587, 0.114));
    
    // Combine saturation and vibrance for better performance
    float satFactor = 1.0;
    float vibFactor = 1.0;
    
    // Calculate saturation factor
    satFactor = mix(1.0, (100.0 + saturation) / 100.0, step(0.001, abs(saturation)));
    
    // Calculate vibrance factor based on current saturation
    float maxChannel = max(max(color.r, color.g), color.b);
    float minChannel = min(min(color.r, color.g), color.b);
    float currentSat = maxChannel - minChannel;
    vibFactor = mix(1.0, (100.0 + vibrance * (1.0 - currentSat)) / 100.0, step(0.001, abs(vibrance)));
    
    // Apply both factors together
    float combinedFactor = satFactor * vibFactor;
    color = mix(vec3(gray), color, combinedFactor);
    
    return color;
}

void main() {
    uvec2 pos = gl_GlobalInvocationID.xy;
    
    uint sourceWidth = uint(params.imageWidth);
    uint sourceHeight = uint(params.imageHeight);
    
    // Calculate crop dimensions
    // Use round() to match CPU implementation
    uint cropStartX = uint(round(params.cropLeft * sourceWidth));
    uint cropStartY = uint(round(params.cropTop * sourceHeight));
    uint cropEndX = uint(round(params.cropRight * sourceWidth));
    uint cropEndY = uint(round(params.cropBottom * sourceHeight));
    uint cropWidth = cropEndX - cropStartX;
    uint cropHeight = cropEndY - cropStartY;
    
    // Check if we're outside the cropped region
    if (pos.x >= cropWidth || pos.y >= cropHeight) {
        return;
    }
    
    // Map output position to source position
    uint sourceX = cropStartX + pos.x;
    uint sourceY = cropStartY + pos.y;
    
    // Calculate buffer indices (byte offsets)
    uint sourcePixelIndex = sourceY * sourceWidth + sourceX;
    uint outputPixelIndex = pos.y * cropWidth + pos.x;
    
    uint inputByteOffset = sourcePixelIndex * 3; // RGB = 3 bytes per pixel
    uint outputByteOffset = outputPixelIndex * 4; // RGBA = 4 bytes per pixel
    
    // Read RGB bytes from input buffer
    // We need to handle byte packing since we're using uint arrays
    uint inputWordIndex = inputByteOffset / 4;
    uint inputByteInWord = inputByteOffset % 4;
    
    uint r, g, b;
    
    // Extract RGB bytes (handling word boundaries)
    if (inputByteInWord == 0) {
        // Aligned: RGB starts at word boundary
        uint word0 = inputBuffer.data[inputWordIndex];
        r = (word0 >> 0) & 0xFF;
        g = (word0 >> 8) & 0xFF;
        b = (word0 >> 16) & 0xFF;
    } else if (inputByteInWord == 1) {
        // RGB spans two words
        uint word0 = inputBuffer.data[inputWordIndex];
        uint word1 = inputBuffer.data[inputWordIndex + 1];
        r = (word0 >> 8) & 0xFF;
        g = (word0 >> 16) & 0xFF;
        b = (word0 >> 24) & 0xFF;
    } else if (inputByteInWord == 2) {
        // RGB spans two words
        uint word0 = inputBuffer.data[inputWordIndex];
        uint word1 = inputBuffer.data[inputWordIndex + 1];
        r = (word0 >> 16) & 0xFF;
        g = (word0 >> 24) & 0xFF;
        b = (word1 >> 0) & 0xFF;
    } else { // inputByteInWord == 3
        // RGB spans two words
        uint word0 = inputBuffer.data[inputWordIndex];
        uint word1 = inputBuffer.data[inputWordIndex + 1];
        r = (word0 >> 24) & 0xFF;
        g = (word1 >> 0) & 0xFF;
        b = (word1 >> 8) & 0xFF;
    }
    
    // Convert to float color
    vec3 color;
    color.r = float(r) / 255.0;
    color.g = float(g) / 255.0;
    color.b = float(b) / 255.0;
    
    // Apply adjustments in order
    color = applyWhiteBalance(color, params.temperature, params.tint);
    color = applyExposure(color, params.exposure);
    color = applyContrast(color, params.contrast);
    color = applyHighlightsShadows(color, params.highlights, params.shadows);
    color = applyBlacksWhites(color, params.blacks, params.whites);
    color = applySaturationVibrance(color, params.saturation, params.vibrance);
    
    // Apply tone curves if enabled
    color = applyToneCurves(color);
    
    // Clamp to valid range
    color = clamp(color, 0.0, 1.0);
    
    // Convert back to bytes
    uint ro = uint(color.r * 255.0);
    uint go = uint(color.g * 255.0);
    uint bo = uint(color.b * 255.0);
    uint ao = 255;
    
    // Write RGBA to output buffer (always aligned to word boundary)
    uint outputWordIndex = outputPixelIndex;
    outputBuffer.data[outputWordIndex] = (ao << 24) | (bo << 16) | (go << 8) | ro;
}